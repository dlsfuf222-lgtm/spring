아주 적절한 “컴파일러가 제너릭으로 인해 자동으로 캐스팅 코드를 생성하는” 예제를 아래에 단계적으로 보여드리겠습니다.
:흰색_확인_표시: 1. 예제 코드 (제너릭 사용)
개발자가 작성한 코드:
```java
List<String> list = new ArrayList<>();
list.add("hello");

String s = list.get(0); // 개발자는 캐스팅 작성 안함
```
위 코드에서 개발자는 list.get(0) 에 대해 캐스팅을 전혀 작성하지 않습니다.
하지만 런타임에는 실제로 캐스팅이 필요합니다.
 (제너릭은 타입 소거로 인해 런타임에는 List 가 List<Object> 비슷한 형태가 되기 때문)
:흰색_확인_표시: 2. 컴파일러가 내부에서 만들어내는 코드 (타입 소거 후)
컴파일러가 제너릭을 제거(Type Erasure)하고 필요한 곳에 자동으로 캐스팅 코드를 삽입하면 다음과 같은 형태가 됩니다:
```java
List list = new ArrayList(); // 제너릭 정보 제거
list.add("hello");

String s = (String) list.get(0); // 컴파일러가 자동으로 생성한 캐스팅
```
여기에서 핵심:
:두꺼운_확인_표시: 개발자는 캐스팅을 작성하지 않았지만
:두꺼운_확인_표시: 컴파일러가 자동으로 (String) 캐스팅 코드를 만들어 넣음
이것이 타입 캐스팅 코드 생성입니다.
:흰색_확인_표시: 3. 컴파일러가 캐스팅을 넣는 이유
제너릭은 컴파일 타임에만 존재하고
 런타임에는 타입 소거로 인해 사라지기 때문입니다.
따라서 런타임에 타입을 보장하려면 컴파일러가 직접 캐스팅을 넣어야 합니다.
:흰색_확인_표시: 더 명확한 예제 (메소드 형태)
개발자가 작성한 코드
```java
public static String first(List<String> list) {
    return list.get(0);
}
```
컴파일러가 만든 바이트코드 기반 "개념적" 변환
```java
public static String first(List list) { // 타입 소거
    return (String) list.get(0);        // 자동 캐스팅 추가
}
```
:압정: 요약
   단계 내용     1 제너릭은 컴파일 타임에만 유지됨   2 컴파일 시 타입 소거(Type Erasure) 진행   3 제너릭 정보가 사라져 원시 타입(raw type)과 유사해짐   4 타입 안정성을 보장하기 위해 컴파일러가 자동 캐스팅 삽입
필요하시면 바이트코드로 실제로 어떻게 나오는지 (javap -c) 분석도 바로 보여드릴 수 있습니다.
